#!/bin/sh

# printc - A portable shell script to simplify colored terminal output
# Usage: printc [-n|--newline] COLOR "text" [COLOR "text" ...]

# --- Helper Functions ---
show_help() {
    echo "Usage: $(basename "$0") [FLAGS] [COLOR \"text\" ...]"
    echo ""
    echo "Description:"
    echo "  Prints text in specified colors to the terminal. Supports multiple"
    echo "  color/text pairs in a single command. Resets color automatically."
    echo ""
    echo "  Colors can be specified by name or number (0-16)."
    echo ""
    echo "Flags:"
    echo "  -n, --newline  Append a newline character at the end of the output."
    echo "  -c, --colors   List all available color names and numbers."
    echo "  -h, --help     Show this help message."
    echo ""
    echo "Examples:"
    echo "  $(basename "$0") Red \"Error: \" White \"File not found.\""
    echo "  $(basename "$0") -n Green \"Success! \" Blue \"Operation completed.\""
    echo "  $(basename "$0") 2 \"Error: \" 16 \"File not found.\"  # Same as first example"
    echo "  $(basename "$0") -n 11 \"[OK]\" 8 \" Test passed\"  # Numbers for brevity"
}

show_colors() {
    echo "Available Colors (Case insensitive):"
    echo ""
    echo "Numeric Shortcuts:"
    echo "  0  = Default/Reset"
    echo "  1  = Black          9  = DarkGray"
    echo "  2  = Red            10 = LightRed"
    echo "  3  = Green          11 = LightGreen"
    echo "  4  = Yellow         12 = LightYellow"
    echo "  5  = Blue           13 = LightBlue"
    echo "  6  = Magenta        14 = LightMagenta"
    echo "  7  = Cyan           15 = LightCyan"
    echo "  8  = LightGray      16 = White"
    echo ""
    echo "Color Preview:"
    # We use the script itself to demo the colors!
    "$0" -n \
        1 "Black " 9 "DarkGray " \
        2 "Red " 10 "LightRed " \
        3 "Green " 11 "LightGreen " \
        4 "Yellow " 12 "LightYellow " \
        5 "Blue " 13 "LightBlue " \
        6 "Magenta " 14 "LightMagenta " \
        7 "Cyan " 15 "LightCyan " \
        8 "LightGray " 16 "White"
}

get_ansi_code() {
    # Convert input to lowercase using tr for portability
    # (Bash 4.0 has ${var,,} but sh does not)
    key=$(echo "$1" | tr '[:upper:]' '[:lower:]')

    case "$key" in
        # Numeric shortcuts (0-17)
        0)  echo "0" ;;   # reset/default
        1)  echo "30" ;;  # black
        2)  echo "31" ;;  # red
        3)  echo "32" ;;  # green
        4)  echo "33" ;;  # yellow
        5)  echo "34" ;;  # blue
        6)  echo "35" ;;  # magenta
        7)  echo "36" ;;  # cyan
        8)  echo "37" ;;  # lightgray
        9)  echo "90" ;;  # darkgray
        10) echo "91" ;;  # lightred
        11) echo "92" ;;  # lightgreen
        12) echo "93" ;;  # lightyellow
        13) echo "94" ;;  # lightblue
        14) echo "95" ;;  # lightmagenta
        15) echo "96" ;;  # lightcyan
        16) echo "97" ;;  # white
        
        # Standard Colors (30-37)
        black)       echo "30" ;;
        red)         echo "31" ;;
        green)       echo "32" ;;
        yellow)      echo "33" ;;
        blue)        echo "34" ;;
        magenta)     echo "35" ;;
        cyan)        echo "36" ;;
        lightgray)   echo "37" ;;
        
        # High Intensity / Bright Colors (90-97)
        darkgray)    echo "90" ;;
        lightred)    echo "91" ;;
        lightgreen)  echo "92" ;;
        lightyellow) echo "93" ;;
        lightblue)   echo "94" ;;
        lightmagenta)echo "95" ;;
        lightcyan)   echo "96" ;;
        white)       echo "97" ;;
        
        # Default / Reset if unknown
        default|reset|none) echo "0" ;;
        *) echo "invalid" ;;
    esac
}

# --- Main Logic ---

use_newline=0

# Handle initial flags
while :; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -c|--colors)
            show_colors
            exit 0
            ;;
        -n|--newline)
            use_newline=1
            shift
            ;;
        *)
            break
            ;;
    esac
done

# Check if we have arguments left
if [ $# -eq 0 ]; then
    # No arguments provided, do nothing or show help? 
    # Standard unix behavior is silent exit on empty input, 
    # but we will just exit cleanly.
    exit 0
fi

# Loop through pairs
while [ $# -gt 0 ]; do
    color_name="$1"
    text_content="$2"

    # Validate we have a pair (Color + Text)
    if [ -z "$text_content" ] && [ $# -eq 1 ]; then
        # Use stderr for system errors
        printf "\033[31mError: Missing text argument for color '%s'\033[0m\n" "$color_name" >&2
        exit 1
    fi

    ansi_code=$(get_ansi_code "$color_name")

    if [ "$ansi_code" = "invalid" ]; then
        # If color is invalid, print raw text but warn on stderr (optional)
        # Here we just treat the color name as uncolored text to be safe, 
        # or we could error out. Let's error out to be helpful.
        printf "\033[31mError: Invalid color name '%s'\033[0m\n" "$color_name" >&2
        exit 1
    fi

    # Print the sequence: Escape [ Code m Text
    printf "\033[%sm%s" "$ansi_code" "$text_content"

    # Shift past the pair
    shift 2
done

# Always reset colors at the end
printf "\033[0m"

# Print newline if requested
if [ "$use_newline" -eq 1 ]; then
    printf "\n"
fi