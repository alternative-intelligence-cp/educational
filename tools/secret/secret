#!/bin/bash
set -e
set -o pipefail
umask 077

# secret - Steganography + encryption vault for sensitive files
# Supports home-based storage by default: $HOME/.secret-vault
# Use --local to keep data beside the script.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_DIR="${SECRET_HOME:-$HOME/.secret-vault}"
BASE_OVERRIDE=""
USE_LOCAL=0

KEY_ID="${SECRET_KEY_ID:-terry_bird}"
PBKDF2_ITER="${SECRET_PBKDF2_ITER:-200000}"
SECURE_DELETE=0
INTERNAL=""
INBOX=""
OUTBOX=""
CNF_FILE=""
DAT_FILE=""
SEC_FILE=""
ARC_FILE=""

TMP_FILES=""
TMP_DIRS=""
LOCK_DIR=""
LOCK_HELD=0

set_paths() {
    INTERNAL="$BASE_DIR/.internal"
    INBOX="$BASE_DIR/inbox"
    OUTBOX="$BASE_DIR/outbox"

    CNF_FILE="$INTERNAL/.${KEY_ID}.cnf"
    DAT_FILE="$INTERNAL/.${KEY_ID}.dat"
    SEC_FILE="$INTERNAL/secret.txt"
    ARC_FILE="$INTERNAL/.${KEY_ID}.tar.gz"
}

warn() {
    printf "Warning: %s\n" "$1" >&2
}

error() {
    printf "Error: %s\n" "$1" >&2
}

append_list() {
    if [ -n "$1" ]; then
        printf '%s\n%s' "$1" "$2"
    else
        printf '%s' "$2"
    fi
}

is_uint() {
    case "$1" in
        ''|*[!0-9]*) return 1 ;;
        *) return 0 ;;
    esac
}

have_cmd() {
    command -v "$1" >/dev/null 2>&1
}

require_cmd() {
    have_cmd "$1" || { error "Missing dependency: $1"; exit 1; }
}

tmp_file() {
    if have_cmd mktemp; then
        local f
        f=$(mktemp "${TMPDIR:-/tmp}/secret.XXXXXX")
        TMP_FILES=$(append_list "$TMP_FILES" "$f")
        printf "%s" "$f"
    else
        local f="${TMPDIR:-/tmp}/secret.$$"
        TMP_FILES=$(append_list "$TMP_FILES" "$f")
        printf "%s" "$f"
    fi
}

tmp_dir() {
    if have_cmd mktemp; then
        local d
        d=$(mktemp -d "${TMPDIR:-/tmp}/secret.XXXXXX")
        TMP_DIRS=$(append_list "$TMP_DIRS" "$d")
        printf "%s" "$d"
    else
        local dir="${TMPDIR:-/tmp}/secret.$$"
        mkdir -p "$dir"
        TMP_DIRS=$(append_list "$TMP_DIRS" "$dir")
        printf "%s" "$dir"
    fi
}

safe_remove() {
    local target="$1"
    [ -e "$target" ] || return 0
    if [ "$SECURE_DELETE" -eq 1 ] && have_cmd shred; then
        shred -u -z "$target" 2>/dev/null || rm -f "$target"
    else
        rm -f "$target"
    fi
}

safe_remove_dir() {
    local target="$1"
    [ -d "$target" ] || return 0
    if [ "$SECURE_DELETE" -eq 1 ] && have_cmd shred; then
        find "$target" -type f -exec shred -u -z {} + 2>/dev/null || true
    fi
    rm -rf "$target"
}

cleanup() {
    if [ -n "$TMP_FILES" ]; then
        local old_ifs=$IFS
        IFS=$(printf '\n')
        for f in $TMP_FILES; do
            [ -n "$f" ] || continue
            safe_remove "$f"
        done
        IFS=$old_ifs
    fi
    if [ -n "$TMP_DIRS" ]; then
        local old_ifs=$IFS
        IFS=$(printf '\n')
        for d in $TMP_DIRS; do
            [ -n "$d" ] || continue
            safe_remove_dir "$d"
        done
        IFS=$old_ifs
    fi
    if [ "$LOCK_HELD" -eq 1 ] && [ -n "$LOCK_DIR" ]; then
        rm -f "$LOCK_DIR/pid" 2>/dev/null || true
        rmdir "$LOCK_DIR" 2>/dev/null || true
        LOCK_HELD=0
    fi
}

trap cleanup EXIT INT TERM

acquire_lock() {
    LOCK_DIR="$INTERNAL/.lock"
    if mkdir "$LOCK_DIR" 2>/dev/null; then
        echo $$ > "$LOCK_DIR/pid" 2>/dev/null || true
        LOCK_HELD=1
        return 0
    fi

    if [ -f "$LOCK_DIR/pid" ]; then
        local lock_pid
        lock_pid=$(cat "$LOCK_DIR/pid" 2>/dev/null || true)
        error "Vault is locked (pid: ${lock_pid:-unknown}). If stale, remove $LOCK_DIR"
    else
        error "Vault is locked. If stale, remove $LOCK_DIR"
    fi
    return 1
}

ensure_dirs() {
    umask 077
    mkdir -p "$INTERNAL" "$INBOX" "$OUTBOX"
    chmod 700 "$INTERNAL" "$INBOX" "$OUTBOX" 2>/dev/null || true
}

clean_inbox() {
    if [ -d "$INBOX" ]; then
        local entry
        for entry in "$INBOX"/*; do
            [ -e "$entry" ] || continue
            if [ -d "$entry" ]; then
                safe_remove_dir "$entry"
            else
                safe_remove "$entry"
            fi
        done
    fi
}

# Derive password from .cnf file
derive_pwd() {
    [ -f "$CNF_FILE" ] || { error "Missing fingerprint file: $CNF_FILE"; return 1; }
    require_cmd base64
    require_cmd sha512sum
    base64 "$CNF_FILE" | sha512sum | cut -c1-36 2>/dev/null
}

# Extract encryption key from .dat file
extract_key() {
    if [ -f "$SEC_FILE" ]; then
        return 0
    fi

    if ! have_cmd steghide; then
        error "steghide not installed (required to extract key)"
        return 1
    fi

    if [ ! -f "$DAT_FILE" ]; then
        error "Missing cover file: $DAT_FILE"
        return 1
    fi

    local pwd
    pwd="$(derive_pwd)" || return 1

    local orig_dir
    orig_dir="$(pwd)"
    cd "$INTERNAL" || return 1

    if ! steghide extract -p "$pwd" -sf "$(basename "$DAT_FILE")" >/dev/null 2>&1; then
        cd "$orig_dir" || true
        return 1
    fi

    if [ -f "secret.txt" ] && [ ! -f "$SEC_FILE" ]; then
        mv "secret.txt" "$SEC_FILE" 2>/dev/null || true
    fi

    cd "$orig_dir" || true
    [ -f "$SEC_FILE" ]
}

# Embed encryption key in .dat file
embed_key() {
    if [ ! -f "$SEC_FILE" ]; then
        return 0
    fi

    if ! have_cmd steghide; then
        warn "steghide not installed; leaving key at $SEC_FILE"
        return 0
    fi

    if [ ! -f "$DAT_FILE" ]; then
        warn "Missing cover file at $DAT_FILE; leaving key at $SEC_FILE"
        return 0
    fi

    local pwd
    pwd="$(derive_pwd)" || return 1

    if ! steghide embed -p "$pwd" -cf "$DAT_FILE" -ef "$SEC_FILE" -Z -q >/dev/null 2>&1; then
        warn "Failed to embed key; leaving key at $SEC_FILE"
        return 1
    fi

    safe_remove "$SEC_FILE" 2>/dev/null || true
}

openssl_enc() {
    local in_file="$1"
    local out_file="$2"
    local pass="$3"
    openssl enc -aes-256-cbc -salt -in "$in_file" -out "$out_file" -pass "pass:${pass}" -pbkdf2 -iter "$PBKDF2_ITER" -md sha256
}

openssl_dec() {
    local in_file="$1"
    local out_file="$2"
    local pass="$3"
    if openssl enc -aes-256-cbc -d -in "$in_file" -out "$out_file" -pass "pass:${pass}" -pbkdf2 -iter "$PBKDF2_ITER" -md sha256 2>/dev/null; then
        return 0
    fi
    # Legacy fallback (older archives without explicit iter)
    openssl enc -aes-256-cbc -d -in "$in_file" -out "$out_file" -pass "pass:${pass}" -pbkdf2 2>/dev/null
}

# Initialize the secret vault
init_vault() {
    require_cmd openssl
    require_cmd tar

    ensure_dirs
    acquire_lock || return 1

    if [ ! -f "$CNF_FILE" ]; then
        openssl rand -hex 32 > "$CNF_FILE"
        chmod 600 "$CNF_FILE" 2>/dev/null || true
    fi

    if [ ! -f "$SEC_FILE" ]; then
        openssl rand -hex 32 > "$SEC_FILE"
        chmod 600 "$SEC_FILE" 2>/dev/null || true
    fi

    if [ ! -f "$DAT_FILE" ]; then
        warn "Cover file not found at $DAT_FILE"
        warn "Place a steghide-compatible file there (jpeg, bmp, wav, au)."
    fi

    embed_key || true

    echo "Vault initialized at: $BASE_DIR"
}

# Pack files from inbox into encrypted archive
pack_files() {
    local strong_pwd="$1"

    ensure_dirs
    require_cmd openssl
    require_cmd tar
    acquire_lock || return 1

    extract_key || { error "Failed to extract key"; return 1; }

    local key
    key="$(cat "$SEC_FILE" 2>/dev/null)"

    if [ ! -d "$INBOX" ] || [ -z "$(ls -A "$INBOX" 2>/dev/null)" ]; then
        echo "Inbox is empty, nothing to pack"
        embed_key
        return 0
    fi

    local tmp_new
    tmp_new="$(tmp_file)"
    tar czf "$tmp_new" -C "$INBOX" . 2>/dev/null || {
        error "Failed to create archive from inbox"
        safe_remove "$tmp_new"
        embed_key
        return 1
    }

    if [ -f "$ARC_FILE" ] && [ -s "$ARC_FILE" ]; then
        local tmp_old
        tmp_old="$(tmp_file)"
        if ! openssl_dec "$ARC_FILE" "$tmp_old" "${key}${strong_pwd}"; then
            mv "$tmp_new" "$tmp_old"
        fi

        local merge_dir
        merge_dir="$(tmp_dir)"
        tar xzf "$tmp_old" -C "$merge_dir" 2>/dev/null || true
        tar xzf "$tmp_new" -C "$merge_dir" 2>/dev/null || true
        tar czf "$ARC_FILE" -C "$merge_dir" . 2>/dev/null

        safe_remove_dir "$merge_dir"
        safe_remove "$tmp_old"
        safe_remove "$tmp_new"
    else
        mv "$tmp_new" "$ARC_FILE"
    fi

    local tmp_enc
    tmp_enc="$(tmp_file)"
    if [ -n "$strong_pwd" ]; then
        openssl_enc "$ARC_FILE" "$tmp_enc" "${key}${strong_pwd}"
    else
        openssl_enc "$ARC_FILE" "$tmp_enc" "${key}"
    fi

    mv "$tmp_enc" "$ARC_FILE"
    chmod 600 "$ARC_FILE" 2>/dev/null || true

    clean_inbox

    echo "Files packed successfully"
    embed_key
}

# Unpack files from archive to outbox
unpack_files() {
    local strong_pwd="$1"

    ensure_dirs
    require_cmd openssl
    require_cmd tar
    acquire_lock || return 1

    extract_key || { error "Failed to extract key"; return 1; }

    local key
    key="$(cat "$SEC_FILE" 2>/dev/null)"

    if [ ! -f "$ARC_FILE" ]; then
        error "No archive found"
        return 1
    fi

    local dec_arc
    dec_arc="$(tmp_file)"
    if [ -n "$strong_pwd" ]; then
        if ! openssl_dec "$ARC_FILE" "$dec_arc" "${key}${strong_pwd}"; then
            error "Decryption failed - wrong password?"
            safe_remove "$dec_arc"
            embed_key
            return 1
        fi
    else
        if ! openssl_dec "$ARC_FILE" "$dec_arc" "${key}"; then
            error "Decryption failed"
            safe_remove "$dec_arc"
            embed_key
            return 1
        fi
    fi

    tar xzf "$dec_arc" -C "$OUTBOX" 2>/dev/null
    safe_remove "$dec_arc"

    echo "Files unpacked to: $OUTBOX"
    embed_key
}

# Peek at specific file content
peek_file() {
    local file_path="$1"
    local strong_pwd="$2"
    local export_var="$3"

    ensure_dirs
    require_cmd openssl
    require_cmd tar
    acquire_lock || return 1

    extract_key || { error "Failed to extract key"; return 1; }

    local key
    key="$(cat "$SEC_FILE" 2>/dev/null)"

    if [ ! -f "$ARC_FILE" ]; then
        error "No archive found"
        embed_key
        return 1
    fi

    local dec_arc
    dec_arc="$(tmp_file)"
    if [ -n "$strong_pwd" ]; then
        if ! openssl_dec "$ARC_FILE" "$dec_arc" "${key}${strong_pwd}"; then
            error "Decryption failed - wrong password?"
            safe_remove "$dec_arc"
            embed_key
            return 1
        fi
    else
        if ! openssl_dec "$ARC_FILE" "$dec_arc" "${key}"; then
            error "Decryption failed"
            safe_remove "$dec_arc"
            embed_key
            return 1
        fi
    fi

    local tmp_dir
    tmp_dir="$(tmp_dir)"
    tar xzf "$dec_arc" -C "$tmp_dir" 2>/dev/null
    safe_remove "$dec_arc"

    local target_file
    target_file="$tmp_dir/${file_path#/}"
    if [ -f "$target_file" ]; then
        if [ -n "$export_var" ]; then
            local content
            content="$(cat "$target_file")"
            local quoted_content
            quoted_content="$(printf '%q' "$content")"
            echo "export $export_var=$quoted_content"
        else
            cat "$target_file"
        fi
    elif [ -d "$target_file" ]; then
        echo "Path is a directory:"
        ls -la "$target_file"
    else
        error "File not found: $file_path"
        safe_remove_dir "$tmp_dir"
        embed_key
        return 1
    fi

    safe_remove_dir "$tmp_dir"
    embed_key
}

list_files() {
    local strong_pwd="$1"

    ensure_dirs
    require_cmd openssl
    require_cmd tar
    acquire_lock || return 1

    extract_key || { error "Failed to extract key"; return 1; }

    local key
    key="$(cat "$SEC_FILE" 2>/dev/null)"

    if [ ! -f "$ARC_FILE" ]; then
        error "No archive found"
        return 1
    fi

    local dec_arc
    dec_arc="$(tmp_file)"
    if [ -n "$strong_pwd" ]; then
        if ! openssl_dec "$ARC_FILE" "$dec_arc" "${key}${strong_pwd}"; then
            error "Decryption failed"
            safe_remove "$dec_arc"
            embed_key
            return 1
        fi
    else
        if ! openssl_dec "$ARC_FILE" "$dec_arc" "${key}"; then
            error "Decryption failed"
            safe_remove "$dec_arc"
            embed_key
            return 1
        fi
    fi

    tar tzf "$dec_arc" 2>/dev/null || echo "Archive is empty or corrupted"
    safe_remove "$dec_arc"
    embed_key
}

status_info() {
    set_paths
    echo "Vault path: $BASE_DIR"
    echo "Internal:   $INTERNAL"
    echo "Inbox:      $INBOX"
    echo "Outbox:     $OUTBOX"
    echo "Key ID:     $KEY_ID"
    echo "PBKDF2 iter: $PBKDF2_ITER"
    echo "Steghide:   $(have_cmd steghide && echo yes || echo no)"
    echo "Cover file: $( [ -f "$DAT_FILE" ] && echo yes || echo no )"
    echo "Key file:   $( [ -f "$SEC_FILE" ] && echo present || echo hidden )"
    echo "Archive:    $( [ -f "$ARC_FILE" ] && echo present || echo missing )"
}

usage() {
    if [ -f "$SCRIPT_DIR/README.md" ]; then
        cat "$SCRIPT_DIR/README.md"
    else
        cat << EOF
Usage: $0 COMMAND [OPTIONS]

Commands:
    --init              Initialize the secret vault
    --pack [--strong PASSWORD]
                        Pack files from inbox/ into encrypted archive
    --unpack [--strong PASSWORD]
                        Unpack archive to outbox/
    --peek PATH [--strong PASSWORD] [--export VAR_NAME]
                        View a specific file from archive without unpacking
                        With --export, outputs 'export VAR_NAME=content' for eval
    --list [--strong PASSWORD]
                        List all files in archive
    --status            Show vault status and configuration
    --help              Show this help message

Options:
    --strong PASSWORD   Use additional password encryption (required if used during pack)
    --export VAR_NAME   Export file contents to environment variable (use with --peek)
                        Usage: eval $(secret --peek file.txt --export MY_VAR)
    --home PATH         Use custom vault location (default: $HOME/.secret-vault)
    --local             Store vault alongside the script
    --iter N            PBKDF2 iterations (default: 200000)
    --shred             Securely delete temp files (requires shred)

Examples:
    $0 --init
    $0 --pack
    $0 --pack --strong mypassword
    $0 --unpack
    $0 --peek credentials.txt
    $0 --peek /path/to/file.txt --strong mypassword
    eval \\$(secret --peek api_key.txt --export API_KEY --strong mypass)
    eval \\$(secret --peek ssh_pass.txt --export SSH_ASKPASS_PASS)
    $0 --status
EOF
    fi
}

# Parse arguments
COMMAND=""
STRONG_PWD=""
PEEK_PATH=""
EXPORT_VAR=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --home)
            shift
            [ -n "$1" ] || { error "--home requires PATH"; exit 1; }
            BASE_OVERRIDE="$1"
            shift
            ;;
        --local)
            USE_LOCAL=1
            shift
            ;;
        --iter)
            shift
            [ -n "$1" ] || { error "--iter requires N"; exit 1; }
            PBKDF2_ITER="$1"
            shift
            ;;
        --shred)
            SECURE_DELETE=1
            shift
            ;;
        --init)
            COMMAND="init"
            shift
            ;;
        --pack)
            COMMAND="pack"
            shift
            ;;
        --unpack)
            COMMAND="unpack"
            shift
            ;;
        --peek)
            COMMAND="peek"
            shift
            if [[ -n "$1" ]] && [[ "$1" != --* ]]; then
                PEEK_PATH="$1"
                shift
            fi
            ;;
        --list)
            COMMAND="list"
            shift
            ;;
        --status)
            COMMAND="status"
            shift
            ;;
        --strong)
            shift
            if [[ -n "$1" ]] && [[ "$1" != --* ]]; then
                STRONG_PWD="$1"
                shift
            else
                error "--strong requires a password"
                exit 1
            fi
            ;;
        --export)
            shift
            if [[ -n "$1" ]] && [[ "$1" != --* ]]; then
                EXPORT_VAR="$1"
                shift
            else
                error "--export requires a variable name"
                exit 1
            fi
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        *)
            if [[ "$COMMAND" == "peek" ]] && [[ -z "$PEEK_PATH" ]]; then
                PEEK_PATH="$1"
                shift
            else
                error "Unknown argument: $1"
                usage
                exit 1
            fi
            ;;
    esac
done

if [ -n "$BASE_OVERRIDE" ]; then
    BASE_DIR="$BASE_OVERRIDE"
fi
if [ "$USE_LOCAL" -eq 1 ]; then
    BASE_DIR="$SCRIPT_DIR"
fi
set_paths

if ! is_uint "$PBKDF2_ITER"; then
    error "--iter must be a positive integer"
    exit 1
fi
if [ "$PBKDF2_ITER" -lt 10000 ]; then
    warn "PBKDF2 iterations set below 10000 may reduce security"
fi
if [ "$SECURE_DELETE" -eq 1 ] && ! have_cmd shred; then
    warn "--shred requested but shred not found; falling back to rm"
fi

# Execute command
case "$COMMAND" in
    init)
        init_vault
        ;;
    pack)
        pack_files "$STRONG_PWD"
        ;;
    unpack)
        unpack_files "$STRONG_PWD"
        ;;
    peek)
        if [ -z "$PEEK_PATH" ]; then
            error "--peek requires a file path"
            usage
            exit 1
        fi
        peek_file "$PEEK_PATH" "$STRONG_PWD" "$EXPORT_VAR"
        ;;
    list)
        list_files "$STRONG_PWD"
        ;;
    status)
        status_info
        ;;
    *)
        error "No command specified"
        usage
        exit 1
        ;;
esac
